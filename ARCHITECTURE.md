# Backend Architecture Guide

## Overview

This document explains the architecture, design patterns, and request flow of the URL Shortener backend. Understanding this architecture will help you navigate the codebase and make informed decisions when adding new features.

## Architecture Layers

Our backend follows a **layered architecture** with clear separation of concerns:

```
┌─────────────────────────────────────────┐
│         HTTP Layer (Router)              │
│  - Route definitions                     │
│  - Middleware chain                      │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│         Handler Layer                   │
│  - HTTP request/response handling       │
│  - Request validation                   │
│  - DTO conversion                        │
│  - Error handling and HTTP responses    │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│         Service Layer                   │
│  - Business logic                       │
│  - Domain rules                         │
│  - Error generation (sentinel errors)   │
│  - Cache coordination (cache-aside)      │
└──────────────┬──────────────────────────┘
               │
       ┌───────┴───────┐
       │               │
┌──────▼──────┐  ┌─────▼──────────────┐
│   Cache     │  │  Repository (DB)   │
│  (Redis)    │  │  - Database queries│
│             │  │  - Data access     │
└─────────────┘  └────────────────────┘
```

## Request Flow

### Example: Creating a Short Link

```
1. HTTP Request
   POST /api/v1/links
   Authorization: Bearer <token>
   Body: {"url": "https://example.com"}

2. Router (pkg/router/router.go)
   - Matches route pattern
   - Applies middleware chain:
     * CORS
     * RequestID
     * RequestLogger
     * Recoverer
     * RequireAuth (extracts user ID)

3. Handler (pkg/handlers/link.go)
   - Decodes JSON body → CreateLinkRequest DTO
   - Extracts userID from context (set by RequireAuth)
   - Calls service: LinkService.CreateShortLink(ctx, userID, url)
   - If error: Checks with errors.Is() and writes error response directly
   - If success: Renders JSON response

4. Service (pkg/service/link.go)
   - Validates URL format
   - Generates random short code
   - Calls repository: queries.TryCreateLink(...)
   - Handles collisions (retries with new code)
   - Returns db.Link or error

5. Repository (pkg/db/links.sql.go - generated by sqlc)
   - Executes SQL query
   - Returns database result or error

### Example: Redirecting a Short Link (with Caching)

```
1. HTTP Request
   GET /{code}

2. Router (pkg/router/router.go)
   - Matches route pattern
   - Applies middleware chain (no auth required for redirects)

3. Handler (pkg/handlers/link.go)
   - Extracts shortcode from URL
   - Calls service: LinkService.GetOriginalURL(ctx, code)
   - If error: Returns 404
   - If success: HTTP redirect to original URL

4. Service (pkg/service/link.go) - Cache-Aside Pattern
   - Check Redis cache first (key: "link:{code}")
   - If cache hit: Return cached URL immediately
   - If cache miss:
     * Query database: queries.GetLinkForRedirect(ctx, code)
     * Populate cache for next time
     * Return result

5. Cache (Redis)
   - Stores: key="link:{code}", value="{original_url}"
   - TTL: 24 hours
   - Invalidated on link deletion/update

6. Repository (pkg/db/links.sql.go - generated by sqlc)
   - Executes SQL query
   - Returns database result or error

6. Response Path
   - Service returns to Handler
   - Handler renders success response
   - OR: Handler checks error with errors.Is()
   - Handler maps error to ErrorResponse DTO
   - Handler logs and writes error response directly
```

## Key Design Principles

### 1. **Dependency Flow**

Dependencies flow **downward only**:

```
Router → Handler → Service → Repository
```

- Router depends on Handlers
- Handlers depend on Services
- Services depend on Repositories
- **Never reverse this flow**

### 2. **Error Handling**

Errors flow **upward** and are handled **directly** where they occur:

```
Repository → Service → Handler (handles errors directly)
```

- Services return Go errors (sentinel errors)
- Handlers check errors with `errors.Is()` and write HTTP responses directly
- No context passing or special middleware - handlers handle errors where they occur

See `ERROR_HANDLING_GUIDE.md` for details.

### 3. **Interface-Based Design**

- Services use interfaces for database access (`LinkQueries`)
- Handlers use interfaces for services (`LinkServiceInterface`)
- This enables testing with mocks

See `INTERFACES_GUIDE.md` for details.

### 4. **Single Responsibility**

Each layer has one clear responsibility:

- **Router**: Route matching and middleware
- **Handler**: HTTP concerns (request/response, validation)
- **Service**: Business logic
- **Repository**: Data access

## Package Structure

```
pkg/
├── config/          # Configuration loading (Viper)
├── db/              # Database layer (sqlc generated + models)
├── dto/             # Data Transfer Objects (request/response)
├── errors/           # Error definitions and mapping
├── handlers/         # HTTP handlers
├── logger/           # Logging abstraction
├── middleware/       # HTTP middleware
├── router/           # Route definitions
└── service/          # Business logic layer (includes caching logic)
```

## Middleware Chain

Middleware executes in this order (top to bottom):

1. **CORS** - Handles cross-origin requests
2. **RequestID** - Adds unique request ID
3. **RequestLogger** - Logs request/response
4. **Recoverer** - Catches panics
5. **RequireAuth** - Validates authentication (on protected routes)
6. **Routes** - Handler execution (handlers handle errors directly)

## Data Flow

### Request → Response

```
HTTP Request
  ↓
Router (parses URL, applies middleware)
  ↓
Handler (validates, converts DTOs)
  ↓
Service (business logic)
  ↓
Repository (database query)
  ↓
Service (processes result)
  ↓
Handler (converts to response DTO)
  ↓
HTTP Response
```

### Error Flow

```
Error occurs (anywhere)
  ↓
Service returns error
  ↓
Handler checks with errors.Is()
  ↓
Handler maps error to ErrorResponse DTO
  ↓
Handler logs error
  ↓
Handler writes HTTP error response directly
```

## Key Patterns

### 1. **Context Pattern**

We use Go's `context.Context` for:
- Request-scoped values (userID, requestID)
- Cancellation/timeouts

### 2. **Interface Segregation**

Interfaces are defined where they're **used**, not where they're **implemented**:

- `LinkServiceInterface` in `handlers/` (used by handlers)
- `LinkQueries` in `service/` (used by services)

This follows the **Interface Segregation Principle**.

### 3. **Dependency Injection**

Dependencies are injected via constructors:

```go
// Service depends on queries interface
func NewLinkService(queries LinkQueries, logger logger.Logger) *LinkService

// Handler depends on service interface
func NewLinkHandler(linkService *service.LinkService, logger logger.Logger) *LinkHandler
```

### 4. **Error Wrapping**

Errors are wrapped with context:

```go
// Service layer
return fmt.Errorf("%w: %v", apperrors.ErrLinkNotFound, err)

// Check with errors.Is()
if errors.Is(err, apperrors.ErrLinkNotFound) {
    // Handle not found
}
```

## Scalability Considerations

### Current (MVP)

- Monolithic service
- Single database
- In-process error handling
- Synchronous operations

### Caching Layer

**Current Implementation**: Redis caching for fast redirect lookups

- **Cache-Aside Pattern**: Service checks cache first, falls back to database
- **Cache Key Format**: `link:{shortcode}` → `{original_url}`
- **TTL**: 24 hours (configurable)
- **Invalidation**: Cache is invalidated when links are deleted or updated

**Cache Flow**:
```
1. GetOriginalURL called
2. Check Redis cache (key: "link:{code}")
3. If hit: Return immediately (fast path)
4. If miss: Query database, populate cache, return result
5. On delete/update: Invalidate cache entry
```

**Note**: Cache is optional - service works with or without Redis. If Redis is unavailable, the service falls back to database queries.

### Future Evolution

The architecture supports evolution to:

- **Microservices**: Each service can become a separate service
- **Caching**: ✅ **Implemented** - Redis caching layer between service and repository
- **Event-driven**: Services can emit events for async processing
- **Multiple databases**: Services can use different data stores

The interface-based design makes these changes easier.

## Testing Strategy

### Unit Tests

- **Services**: Mock `LinkQueries` interface
- **Handlers**: Mock `LinkServiceInterface`
- **Error handling**: Test error handling logic in handlers

### Integration Tests

- Test full request flow
- Use test database
- Test middleware chain

## Common Questions

### Q: Where do I add new business logic?

**A**: In the **Service layer** (`pkg/service/`). Services contain all business logic.

### Q: Where do I add new API endpoints?

**A**: 
1. Add route in `pkg/router/router.go`
2. Add handler method in `pkg/handlers/`
3. Add service method if needed in `pkg/service/`
4. Add database query if needed in `queries/` (then run sqlc)

### Q: How do I handle errors?

**A**: 
1. Services: Return sentinel errors or wrap errors with `fmt.Errorf("%w", ...)`
2. Handlers: Check errors with `errors.Is()` and write HTTP responses directly
3. Use `handleError()` helper to avoid repetition

### Q: Where do I add new error types?

**A**: In `pkg/errors/errors.go`:
1. Add error code constant (if needed for frontend handling)
2. Add sentinel error (if checked in multiple places)
3. Update handler's `handleError()` method to handle the new error

### Q: How do I add new middleware?

**A**: 
1. Create middleware function in `pkg/middleware/`
2. Add to middleware chain in `pkg/server.go` or `pkg/router/router.go`
3. Consider execution order (auth before routes)

## Further Reading

- `ERROR_HANDLING_GUIDE.md` - Error handling architecture
- `INTERFACES_GUIDE.md` - Why and how we use interfaces
- `PROJECT_STRUCTURE.md` - Directory structure details
- `SERVICE_PATTERNS.md` - How to create services
- `HANDLER_PATTERNS.md` - How to create handlers

