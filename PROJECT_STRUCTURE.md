# Project Structure Guide

## Overview

This document explains the directory structure, what goes where, and why. Understanding the structure helps you know where to add new code and find existing functionality.

## Root Structure

```
url-shortener/
├── client/              # Frontend (React/TypeScript)
├── server/              # Backend (Go)
├── *.md                 # Documentation files
└── README.md            # Project overview
```

## Server Structure

```
server/
├── cmd/
│   └── main.go          # Application entry point
├── pkg/                  # Main application code
│   ├── config/          # Configuration
│   ├── db/              # Database layer
│   ├── dto/             # Data Transfer Objects
│   ├── errors/          # Error definitions
│   ├── handlers/        # HTTP handlers
│   ├── logger/          # Logging
│   ├── middleware/      # HTTP middleware
│   ├── router/          # Route definitions
│   ├── service/         # Business logic
│   └── server.go        # Server setup
├── queries/             # SQL queries (input for sqlc)
├── migrations/          # Database migrations
├── docs/                # API documentation
│   └── openapi.yaml     # OpenAPI spec
├── go.mod               # Go dependencies
└── sqlc.yaml            # sqlc configuration
```

## Package Details

### `cmd/main.go`

**Purpose**: Application entry point

**Contains**:
- Configuration loading
- Logger initialization
- Server creation
- Graceful shutdown handling

**Why separate?**: Follows Go best practice of keeping `main` minimal and delegating to packages.

**When to modify**: Only when changing startup behavior or adding new initialization.

---

### `pkg/config/`

**Purpose**: Configuration management

**Contains**:
- Configuration struct
- Environment variable loading (Viper)
- Default values

**Pattern**: Single `config.go` file with `Load()` function.

**When to add**: New configuration values (database URLs, API keys, etc.)

---

### `pkg/db/`

**Purpose**: Database layer (generated by sqlc)

**Contains**:
- `db.go` - Database connection and Queries struct
- `models.go` - Database models (generated)
- `*.sql.go` - Query functions (generated from `queries/*.sql`)

**Important**: 
- **Don't edit generated files** (`models.go`, `*.sql.go`)
- Edit SQL in `queries/` directory
- Run `sqlc generate` to regenerate

**When to modify**:
- Add new queries: Add SQL to `queries/` directory
- Change models: Update SQL migrations, then regenerate

---

### `pkg/dto/`

**Purpose**: Data Transfer Objects (request/response structures)

**Contains**:
- Request DTOs (e.g., `CreateLinkRequest`)
- Response DTOs (e.g., `SuccessResponse[T]`)

**Pattern**: 
- One file per resource or logical grouping
- JSON tags for serialization
- No business logic

**When to add**: New API endpoints need new request/response structures

**Example**:
```go
type CreateLinkRequest struct {
    URL string `json:"url"`
}
```

---

### `pkg/errors/`

**Purpose**: Error definitions and mapping

**Contains**:
- Error code constants
- Sentinel errors (for service layer)
- `ErrorResponse` and `ErrorDetail` DTOs (for HTTP responses)

**Pattern**: All error-related code in one place

**When to add**:
- New error codes: Add constant (only if frontend needs special handling)
- New sentinel errors: Add if error is checked in multiple places

**See**: `ERROR_HANDLING_GUIDE.md` for details

---

### `pkg/handlers/`

**Purpose**: HTTP request/response handling

**Contains**:
- Handler structs (one per resource)
- HTTP handler methods
- Request validation
- DTO conversion
- Error handling and HTTP responses

**Pattern**:
- One file per resource (e.g., `link.go`, `user.go`)
- Handler struct with dependencies
- Methods match HTTP verbs (CreateLink, ListLinks, etc.)

**When to add**: New API endpoints

**Example structure**:
```go
type LinkHandler struct {
    LinkService LinkServiceInterface
    logger      logger.Logger
}

func (h *LinkHandler) CreateLink(w http.ResponseWriter, r *http.Request) {
    // 1. Decode request
    // 2. Validate
    // 3. Call service
    // 4. Handle errors (check with errors.Is(), write response)
    // 5. Render response
}
```

**See**: `HANDLER_PATTERNS.md` for details

---

### `pkg/logger/`

**Purpose**: Logging abstraction

**Contains**:
- Logger interface/implementation
- Zap wrapper for structured logging
- Environment-specific configuration

**Pattern**: Single `logger.go` file

**When to modify**: Changing logging behavior or adding new log levels

---

### `pkg/middleware/`

**Purpose**: HTTP middleware

**Contains**:
- `auth.go` - Authentication middleware
- `error_handler.go` - Error handling middleware
- `request_logger.go` - Request logging middleware

**Pattern**: One file per middleware concern

**When to add**: New cross-cutting concerns (rate limiting, metrics, etc.)

**Example**:
```go
func NewMiddleware(log logger.Logger) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // Before handler
            next.ServeHTTP(w, r)
            // After handler
        })
    }
}
```

---

### `pkg/router/`

**Purpose**: Route definitions

**Contains**:
- Route patterns
- Middleware application per route group
- Handler mounting

**Pattern**: Single `router.go` file with `New()` function

**When to add**: New routes or route groups

**Example**:
```go
r.Route("/api/v1/links", func(r chi.Router) {
    r.Get("/", linkH.ListLinks)
    r.Post("/", linkH.CreateLink)
})
```

---

### `pkg/service/`

**Purpose**: Business logic layer

**Contains**:
- Service structs (one per resource)
- Business logic methods
- Validation
- Error generation (sentinel errors)

**Pattern**:
- One file per resource
- Service struct with dependencies (queries interface, logger)
- Methods contain business logic

**When to add**: New business logic or resources

**Example structure**:
```go
type LinkService struct {
    queries LinkQueries  // Interface, not concrete type
    logger  logger.Logger
}

func (s *LinkService) CreateShortLink(ctx context.Context, userID string, url string) (db.Link, error) {
    // Business logic here
}
```

**See**: `SERVICE_PATTERNS.md` for details

---

### `pkg/server.go`

**Purpose**: Server setup and initialization

**Contains**:
- Server struct
- Dependency wiring
- Middleware chain setup
- Router mounting

**Pattern**: Single file with `New()` function

**When to modify**: Adding new middleware or changing server setup

---

### `queries/`

**Purpose**: SQL queries (input for sqlc)

**Contains**:
- `.sql` files with SQL queries
- sqlc annotations (`-- name: FunctionName :one/:many/:exec`)

**Pattern**: One file per resource or logical grouping

**When to add**: New database queries

**Example**:
```sql
-- name: GetLinkByID :one
SELECT * FROM links WHERE id = $1;
```

**Important**: Run `sqlc generate` after adding queries

---

### `migrations/`

**Purpose**: Database schema migrations

**Contains**:
- Migration files (numbered, `.up.sql` and `.down.sql`)

**Pattern**: Sequential numbering, descriptive names

**When to add**: Schema changes

**Example**:
```
000001_create_links_table.up.sql
000001_create_links_table.down.sql
000002_add_index_to_links.up.sql
000002_add_index_to_links.down.sql
```

---

### `docs/`

**Purpose**: API documentation

**Contains**:
- `openapi.yaml` - OpenAPI specification

**When to modify**: API changes

---

## File Naming Conventions

### Go Files

- **Lowercase with underscores**: `link_handler.go`, `error_handler.go`
- **Test files**: `*_test.go`
- **One main type per file** (usually)

### SQL Files

- **Descriptive names**: `links.sql`, `users.sql`
- **Migration files**: `000001_description.up.sql`

### Documentation

- **UPPERCASE**: `ARCHITECTURE.md`, `ERROR_HANDLING_GUIDE.md`
- **Descriptive names**: Clear what the document covers

## Where to Add New Code

### Adding a New Resource (e.g., "Users")

1. **Database**: Add migration in `migrations/`
2. **Queries**: Add SQL in `queries/users.sql`
3. **Generate**: Run `sqlc generate` (creates `pkg/db/users.sql.go`)
4. **Service**: Create `pkg/service/user.go`
5. **Handler**: Create `pkg/handlers/user.go`
6. **DTOs**: Add to `pkg/dto/dto.go` or create `pkg/dto/user.go`
7. **Routes**: Add routes in `pkg/router/router.go`
8. **Errors**: Add error codes in `pkg/errors/errors.go` if needed

### Adding a New Endpoint

1. **Handler method**: Add to appropriate handler file
2. **Service method**: Add if business logic needed
3. **Route**: Add to `pkg/router/router.go`
4. **DTOs**: Add request/response DTOs if needed

### Adding New Middleware

1. **Create file**: `pkg/middleware/new_middleware.go`
2. **Add to chain**: In `pkg/server.go` or `pkg/router/router.go`
3. **Consider order**: Where should it run in the chain?

## Common Mistakes

### ❌ Don't:

- Edit generated files (`pkg/db/*.sql.go`, `pkg/db/models.go`)
- Put business logic in handlers
- Put HTTP concerns in services
- Create circular dependencies
- Mix error handling with business logic

### ✅ Do:

- Keep layers separate
- Use interfaces for dependencies
- Follow the established patterns
- Add tests for new code
- Update documentation

## Further Reading

- `ARCHITECTURE.md` - Overall architecture
- `SERVICE_PATTERNS.md` - Service layer patterns
- `HANDLER_PATTERNS.md` - Handler layer patterns
- `DEVELOPMENT_GUIDE.md` - Setup and development workflow

